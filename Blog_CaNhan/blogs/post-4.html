<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Đã cập nhật tiêu đề -->
    <title>Nền Tảng Kỹ Thuật: Tầm Quan Trọng Của CTDL & Giải Thuật</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Toàn bộ CSS từ post-1.html được sao chép vào đây */
        :root {
            --primary-color: #f8f9fa;
            --secondary-color: #ffffff;
            --accent-color: #0d6efd;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            scroll-behavior: smooth;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        #tech-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header (KHÔNG THAY ĐỔI) */
        header {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 20px 0;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-color);
            text-decoration: none;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }

        nav ul li a {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
            font-weight: 500;
        }

        nav ul li a:hover, nav ul li a.active {
            color: var(--accent-color);
        }
        
        /* CSS cho trang bài viết chi tiết (GIỐNG HỆT POST-1) */
        .post-page-container {
            max-width: 800px; /* Giới hạn chiều rộng nội dung bài viết */
            margin: 0 auto;
            padding: 150px 20px 100px 20px; /* Padding trên cùng để né header */
            background-color: var(--secondary-color);
            min-height: 100vh;
        }
        
        .post-page-title {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        .post-page-content .post-meta {
            display: flex;
            flex-wrap: wrap; /* Thêm cho responsive */
            gap: 10px 20px; /* Thêm gap */
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        
        .post-page-content .post-date,
        .post-page-content .post-author { /* Thêm post-author */
            color: var(--text-secondary);
        }
        
        .post-page-content .post-category {
            background: rgba(13, 110, 253, 0.1);
            color: var(--accent-color);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .post-page-content .post-full-content {
            color: var(--text-color); /* Chữ nội dung rõ hơn */
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .post-page-content .post-full-content h2, 
        .post-page-content .post-full-content h3 {
             color: var(--text-color); 
             margin: 40px 0 15px;
        }

        .post-page-content .post-full-content h2 {
             font-size: 2rem;
             border-bottom: 2px solid var(--border-color);
             padding-bottom: 10px;
        }

         .post-page-content .post-full-content h3 {
             font-size: 1.5rem;
         }
        
        .post-page-content .post-full-content p {
            margin-bottom: 20px;
            color: var(--text-secondary); /* Chỉnh lại màu p */
        }
        
        .post-page-content .post-full-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
            background-color: #eee; /* Nền cho ảnh placeholder */
        }
        
        .post-page-content .post-full-content pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
            margin: 20px 0;
        }
        .post-page-content .post-full-content code {
            font-family: 'Courier New', Courier, monospace;
        }
        .post-page-content .post-full-content blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin: 20px 0;
            font-style: italic;
            color: var(--text-secondary);
        }
        .post-page-content .post-full-content ul, 
        .post-page-content .post-full-content ol { /* Thêm ol */
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        /* Footer */
        footer {
            padding: 50px 0 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--primary-color);
        }

        .copyright {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <canvas id="tech-background"></canvas>
    <!-- Header (KHÔNG THAY ĐỔI) -->
    <header>
        <div class="container">
            <div class="header-content">
                <a href="../index.html" class="logo">My IT Journey Blog</a>
                <nav>
                    <ul>
                        <li><a href="../index.html">Trang Chủ</a></li>
                        <li><a href="../index.html#blog" class="active">Bài Viết</a></li>
                        <li><a href="../about.html">Về Tôi</a></li>
                        <li><a href="../index.html#contact">Liên Hệ</a></li>
                    </ul>
                </nav>
                <div class="mobile-menu">☰</div>
            </div>
        </div>
    </header>

    <main>
         <!-- Nội dung bài viết chi tiết -->
        <div class="post-page-container">
            <!-- === BẮT ĐẦU NỘI DUNG THAY THẾ CHO POST 4 === -->
            
            <h1 class="post-page-title">Nền Tảng Của Kỹ Thuật: Tầm Quan Trọng Của Cấu Trúc Dữ Liệu & Giải Thuật (CTDL & GT)</h1>
            
            <div class="post-page-content">
                <div class="post-meta">
                    <span class="post-date"><i class="fas fa-calendar-alt"></i> Ngày đăng: 28/10/2025</span>
                    
                    <span class="post-category">Học thuật</span>
                </div>
                
                <div class="post-full-content">
                    <p>Khi mới học, chúng ta tập trung vào việc "làm cho code chạy". Nhưng khi bước vào các hệ thống phức tạp, câu hỏi trở thành "làm thế nào để code chạy hiệu quả?". Đây là lúc Cấu trúc Dữ liệu và Giải thuật (CTDL & GT) thể hiện vai trò then chốt. Chúng là ngôn ngữ chung để đo lường và tối ưu hóa hiệu suất.</p>

                    <h2>Big O Notation: Ngôn Ngữ Của Hiệu Suất</h2>
                    <p>Tại sao một ứng dụng chạy mượt mà, trong khi một ứng dụng khác lại "lag" khi dữ liệu tăng lên? Câu trả lời nằm ở "Độ phức tạp thuật toán" (Time & Space Complexity), thường được biểu diễn qua Big O Notation. Đây là cách chúng ta dự đoán hành vi của thuật toán khi quy mô đầu vào (input size) tăng lên.</p>
                    <ul>
                        <li><strong>O(1) - Constant Time:</strong> Cực nhanh. Thời gian thực thi không phụ thuộc vào kích thước input. (VD: Truy cập một phần tử trong Array bằng index).</li>
                        <li><strong>O(log n) - Logarithmic Time:</strong> Rất nhanh. Thời gian tăng chậm khi input tăng. (VD: Tìm kiếm nhị phân - Binary Search).</li>
                        <li><strong>O(n) - Linear Time:</strong> Tốc độ tỉ lệ thuận với input. (VD: Duyệt qua một Array).</li>
                        <li><strong>O(n log n) - Linearithmic Time:</strong> Khá hiệu quả cho nhiều thuật toán sắp xếp. (VD: Merge Sort, Quick Sort trung bình).</li>
                        <li><strong>O(n²) - Quadratic Time:</strong> Chấp nhận được với input nhỏ, rất chậm khi n lớn. (VD: Vòng lặp lồng nhau duyệt qua cặp phần tử).</li>
                        <li><strong>O(2ⁿ) - Exponential Time:</strong> Cực kỳ chậm, thường không khả thi với input lớn. (VD: Một số giải thuật đệ quy brute-force).</li>
                    </ul>
                    <img src="../images/post/unnamed 3.jpg" alt="Biểu đồ Big O">

                    <h2>Case Study: Array vs. HashMap (Map/Object)</h2>
                    <p>Hãy xem một ví dụ thực tế: tìm kiếm thông tin người dùng bằng ID trong một danh sách lớn.</p>
                    
                    <h3>Phương án 1: Dùng Mảng (Array)</h3>
                    <p>Nếu chúng ta lưu 1,000,000 người dùng trong một mảng, để tìm một ID cụ thể, chúng ta có thể phải duyệt qua từng người dùng một. Đây là thuật toán tìm kiếm tuyến tính (Linear Search) với độ phức tạp thời gian là <strong>O(n)</strong>. Trong trường hợp xấu nhất, chúng ta phải thực hiện 1,000,000 phép so sánh.</p>
                    <pre><code>// Độ phức tạp O(n) - Time Complexity
// Độ phức tạp O(1) - Space Complexity (không dùng thêm bộ nhớ đáng kể)
function findUserById_Array(users, id) {
    for (let i = 0; i < users.length; i++) {
        if (users[i].id === id) {
            return users[i]; // Tìm thấy
        }
    }
    return null; // Không tìm thấy
}</code></pre>
                    
                    <h3>Phương án 2: Dùng Bảng Băm (HashMap/Map/Object)</h3>
                    <p>Nếu chúng ta dùng Map (hoặc Object trong JS) với `key` là `id` và `value` là `user object`, việc tìm kiếm gần như là tức thời. Bảng băm cho phép truy cập trực tiếp vào vị trí bộ nhớ dựa trên key đã được hash. Độ phức tạp thời gian trung bình là <strong>O(1)</strong>. Bất kể bạn có 1 triệu hay 10 triệu người dùng, tốc độ truy cập gần như không đổi (trừ trường hợp hash collision hiếm gặp).</p>
                    <pre><code>// Độ phức tạp O(1) - Average Time Complexity
// Độ phức tạp O(n) - Space Complexity (cần thêm bộ nhớ để lưu Map/Object)

// Giả sử 'usersMap' là một Map() hoặc Object đã được tạo trước
// Ví dụ: const usersMap = new Map(); users.forEach(user => usersMap.set(user.id, user));
// Hoặc: const usersMap = {}; users.forEach(user => usersMap[user.id] = user);

function findUserById_Map(usersMap, id) {
    // Với Map: return usersMap.get(id) || null;
    // Với Object: 
    return usersMap[id] || null; 
}</code></pre>
                    <p>Tuy nhiên, đánh đổi là chúng ta cần thêm bộ nhớ (Space Complexity là O(n)) để lưu trữ cấu trúc Map/Object này.</p>

                    <h2>Kết Luận</h2>
                    <p>CTDL & GT không phải là những khái niệm lý thuyết suông để vượt qua phỏng vấn. Chúng là bộ công cụ nền tảng giúp kỹ sư phần mềm đưa ra quyết định kiến trúc đúng đắn, cân bằng giữa tốc độ thực thi và việc sử dụng tài nguyên (thời gian vs. bộ nhớ). Lựa chọn sai cấu trúc dữ liệu hoặc thuật toán có thể "giết chết" hiệu năng của cả một hệ thống lớn.</p>
                </div>
            </div>
            <!-- === KẾT THÚC NỘI DUNG THAY THẾ CHO POST 4 === -->
        </div>
    </main>

    <!-- Footer (KHÔNG THAY ĐỔI) -->
    <footer>
        <div class="container">
            <div class="copyright">
                &copy; 2025 IT Journey Blog. Được tạo với ❤️ và nhiều ☕
            </div>
        </div>
    </footer>

    <!-- JavaScript (KHÔNG THAY ĐỔI) -->
    <script>
        // --- HIỆU ỨNG NỀN MẠCH ĐIỆN TỬ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tech-background');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particles = [];
            const particleCount = (canvas.width * canvas.height) / 20000;
            const lineColor = 'rgba(13, 110, 253, 0.5)';
            const particleColor = 'rgba(13, 110, 253, 0.5)';

            function Particle(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                ));
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    p1.x += p1.vx; p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;
                    ctx.beginPath(); ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2); ctx.fillStyle = particleColor; ctx.fill();
                    for (let j = i + 1; j < particles.length; j++) {
                        const p2 = particles[j];
                        const dx = p1.x - p2.x; const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 120) {
                            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = lineColor; ctx.lineWidth = 0.5; ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            
            window.addEventListener('resize', () => {
                 canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                 particles = [];
                 const newParticleCount = (canvas.width * canvas.height) / 20000;
                 for (let i = 0; i < newParticleCount; i++) {
                    particles.push(new Particle(
                        Math.random() * canvas.width, Math.random() * canvas.height,
                        (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                    ));
                }
            });
            draw();
        });
    </script>

    <script src="../cursor-trail.js"></script>
</body>
</html>

