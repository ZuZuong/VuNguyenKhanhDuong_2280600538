<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Đã cập nhật tiêu đề -->
    <title>Xử Lý Bất Đồng Bộ Trong JavaScript: Từ Callback Hell Đến Async/Await</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Toàn bộ CSS từ post-1.html được sao chép vào đây */
        :root {
            --primary-color: #f8f9fa;
            --secondary-color: #ffffff;
            --accent-color: #0d6efd;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            scroll-behavior: smooth;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        #tech-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header (KHÔNG THAY ĐỔI) */
        header {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 20px 0;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-color);
            text-decoration: none;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }

        nav ul li a {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
            font-weight: 500;
        }

        nav ul li a:hover, nav ul li a.active {
            color: var(--accent-color);
        }
        
        /* CSS cho trang bài viết chi tiết (GIỐNG HỆT POST-1) */
        .post-page-container {
            max-width: 800px; /* Giới hạn chiều rộng nội dung bài viết */
            margin: 0 auto;
            padding: 150px 20px 100px 20px; /* Padding trên cùng để né header */
            background-color: var(--secondary-color);
            min-height: 100vh;
        }
        
        .post-page-title {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        .post-page-content .post-meta {
            display: flex;
            flex-wrap: wrap; /* Thêm cho responsive */
            gap: 10px 20px; /* Thêm gap */
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        
        .post-page-content .post-date,
        .post-page-content .post-author { /* Thêm post-author */
            color: var(--text-secondary);
        }
        
        .post-page-content .post-category {
            background: rgba(13, 110, 253, 0.1);
            color: var(--accent-color);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .post-page-content .post-full-content {
            color: var(--text-color); /* Chữ nội dung rõ hơn */
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .post-page-content .post-full-content h2, 
        .post-page-content .post-full-content h3 {
             color: var(--text-color); 
             margin: 40px 0 15px;
        }

        .post-page-content .post-full-content h2 {
             font-size: 2rem;
             border-bottom: 2px solid var(--border-color);
             padding-bottom: 10px;
        }

         .post-page-content .post-full-content h3 {
             font-size: 1.5rem;
         }
        
        .post-page-content .post-full-content p {
            margin-bottom: 20px;
            color: var(--text-secondary); /* Chỉnh lại màu p */
        }
        
        .post-page-content .post-full-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
            background-color: #eee; /* Nền cho ảnh placeholder */
        }
        
        .post-page-content .post-full-content pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
            margin: 20px 0;
        }
        .post-page-content .post-full-content code {
            font-family: 'Courier New', Courier, monospace;
        }
        .post-page-content .post-full-content blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin: 20px 0;
            font-style: italic;
            color: var(--text-secondary);
        }
        .post-page-content .post-full-content ul, 
        .post-page-content .post-full-content ol { /* Thêm ol */
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        /* Footer */
        footer {
            padding: 50px 0 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--primary-color);
        }

        .copyright {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <canvas id="tech-background"></canvas>
    <!-- Header (KHÔNG THAY ĐỔI) -->
    <header>
        <div class="container">
            <div class="header-content">
                <a href="../index.html" class="logo">My IT Journey Blog</a>
                <nav>
                    <ul>
                        <li><a href="../index.html">Trang Chủ</a></li>
                        <li><a href="../index.html#blog" class="active">Bài Viết</a></li>
                        <li><a href="../about.html">Về Tôi</a></li>
                        <li><a href="../index.html#contact">Liên Hệ</a></li>
                    </ul>
                </nav>
                <div class="mobile-menu">☰</div>
            </div>
        </div>
    </header>

    <main>
         <!-- Nội dung bài viết chi tiết -->
        <div class="post-page-container">
            <!-- === BẮT ĐẦU NỘI DUNG THAY THẾ CHO POST 8 === -->
            
            <h1 class="post-page-title">Xử Lý Bất Đồng Bộ Trong JavaScript: Từ "Callback Hell" Đến Async/Await</h1>
            
            <div class="post-page-content">
                <div class="post-meta">
                    <span class="post-date"><i class="fas fa-calendar-alt"></i> Ngày đăng: 10/11/2025</span>
                    
                    <span class="post-category">JavaScript</span>
                </div>
                
                <div class="post-full-content">
                    <p>JavaScript, về bản chất, là một ngôn ngữ đơn luồng (single-threaded), nghĩa là nó chỉ có thể thực thi một tác vụ tại một thời điểm. Tuy nhiên, trong môi trường trình duyệt và Node.js, nó lại có khả năng xử lý các tác vụ bất đồng bộ (asynchronous) một cách hiệu quả thông qua cơ chế "Event Loop". Điều này cực kỳ quan trọng đối với các ứng dụng web hiện đại, nơi chúng ta thường xuyên phải chờ đợi các hoạt động I/O (Input/Output) như gọi API, đọc/ghi file, tương tác người dùng mà không làm "đóng băng" luồng chính.</p>
                    <p>Quản lý sự bất đồng bộ này, tuy nhiên, là một trong những khía cạnh gây nhiều khó khăn nhất cho lập trình viên JavaScript, dẫn đến sự tiến hóa của các mô hình xử lý qua nhiều phiên bản ngôn ngữ.</p>

                    <h2>Giai đoạn 1: Cơn Ác Mộng "Callback Hell"</h2>
                    <p>Trong những ngày đầu của JavaScript và Node.js, callbacks (hàm gọi lại) là phương pháp chính để xử lý kết quả của một tác vụ bất đồng bộ. Một hàm bất đồng bộ sẽ nhận một hàm khác làm tham số (callback), và gọi hàm đó khi tác vụ hoàn thành (hoặc gặp lỗi).</p>
                    <p>Vấn đề nảy sinh khi chúng ta có nhiều tác vụ bất đồng bộ phụ thuộc tuần tự vào nhau. Mỗi tác vụ sau phải nằm trong callback của tác vụ trước, tạo ra một cấu trúc code lồng vào nhau sâu dần, thường được gọi một cách mỉa mai là "Callback Hell" hay "Pyramid of Doom".</p>
                    
                    <pre><code class="language-javascript">// Callback Hell - Khó đọc, khó debug, khó bảo trì
step1(function (value1) {
    step2(value1, function(value2) {
        step3(value2, function(value3) {
            step4(value3, function(value4) {
                // ... Cứ thế lồng sâu hơn nữa
                console.log('Hoàn thành tất cả các bước');
            }, function(error4) { /* Xử lý lỗi cho step4 */ });
        }, function(error3) { /* Xử lý lỗi cho step3 */ });
    }, function(error2) { /* Xử lý lỗi cho step2 */ });
}, function(error1) { /* Xử lý lỗi cho step1 */ });
</code></pre>
                    <p>Cấu trúc này không chỉ khó đọc mà còn rất khó để xử lý lỗi một cách nhất quán.</p>

                    <h2>Giai đoạn 2: Sự Cứu Rỗi Từ Promises</h2>
                    <p>ES6 (ECMAScript 2015) giới thiệu Promises như một giải pháp thanh lịch hơn. Promise là một đối tượng đại diện cho *kết quả cuối cùng* của một hoạt động bất đồng bộ. Một Promise có thể ở một trong ba trạng thái:</p>
                    <ul>
                        <li><strong>Pending:</strong> Trạng thái ban đầu, chưa hoàn thành hay thất bại.</li>
                        <li><strong>Fulfilled (Resolved):</strong> Tác vụ đã hoàn thành thành công.</li>
                        <li><strong>Rejected:</strong> Tác vụ đã thất bại.</li>
                    </ul>
                    <p>Promises cho phép chúng ta "xếp hàng" (chaining) các tác vụ bất đồng bộ bằng phương thức <code>.then()</code> (được gọi khi Promise fulfilled) và xử lý lỗi một cách tập trung, dễ dàng hơn bằng <code>.catch()</code> (được gọi khi bất kỳ Promise nào trong chuỗi bị rejected).</p>
                    
                    <pre><code class="language-javascript">// Sử dụng Promises - Dễ đọc hơn, xử lý lỗi tốt hơn
step1()
    .then(value1 => step2(value1)) // .then trả về một Promise mới
    .then(value2 => step3(value2))
    .then(value3 => step4(value3))
    .then(value4 => {
        console.log('Hoàn thành tất cả các bước');
    })
    .catch(error => {
        // Bắt lỗi ở bất kỳ bước nào trong chuỗi .then
        console.error('Đã xảy ra lỗi:', error);
    });
</code></pre>
                    <p>Promise đã làm phẳng đáng kể cấu trúc code so với Callback Hell.</p>
                    
                    <img src="../images/post/unnamed 8.jpg" alt="So sánh cấu trúc code Callback và Promise">

                    <h2>Giai đoạn 3: Async/Await - Cú Pháp Của Sự Thanh Lịch</h2>
                    <p>ES2017 (ES8) mang đến <code>async</code> và <code>await</code>, thực chất chỉ là "cú pháp" (syntactic sugar) được xây dựng trên nền tảng Promises. Chúng cho phép chúng ta viết code bất đồng bộ theo phong cách *trông giống như* code đồng bộ (tuần tự), giúp code trở nên cực kỳ trực quan, dễ đọc và dễ debug.</p>
                    <ul>
                        <li><strong><code>async</code>:</strong> Từ khóa đặt trước một hàm để chỉ ra rằng hàm đó sẽ xử lý các tác vụ bất đồng bộ và *luôn luôn* trả về một Promise.</li>
                        <li><strong><code>await</code>:</strong> Chỉ có thể được sử dụng bên trong một hàm <code>async</code>. Nó đứng trước một biểu thức trả về Promise và sẽ *tạm dừng* việc thực thi của hàm <code>async</code> cho đến khi Promise đó được giải quyết (fulfilled hoặc rejected). Nếu fulfilled, nó trả về giá trị đã giải quyết. Nếu rejected, nó ném ra lỗi (có thể bắt bằng <code>try...catch</code>).</li>
                    </ul>

                    <pre><code class="language-javascript">// Sử dụng Async/Await - Trực quan như code đồng bộ
async function performSteps() {
    try {
        const value1 = await step1(); // Tạm dừng cho đến khi step1() hoàn thành
        const value2 = await step2(value1); // Tạm dừng ...
        const value3 = await step3(value2); // Tạm dừng ...
        const value4 = await step4(value3); // Tạm dừng ...
        console.log('Hoàn thành tất cả các bước');
    } catch (error) {
        // Bắt lỗi từ bất kỳ bước nào có await bị rejected
        console.error('Đã xảy ra lỗi:', error);
    }
}

performSteps(); // Gọi hàm async
</code></pre>
                    <p>Việc sử dụng <code>try...catch</code> với <code>async/await</code> cung cấp một cơ chế xử lý lỗi quen thuộc và mạnh mẽ.</p>

                    <h2>Kết Luận</h2>
                    <p>Sự tiến hóa từ Callbacks đến Promises và cuối cùng là Async/Await là một minh chứng cho sự trưởng thành của JavaScript trong việc giải quyết bài toán xử lý bất đồng bộ, một yêu cầu cốt lõi của các ứng dụng web và backend hiện đại. Việc thành thạo <code>async/await</code> không chỉ giúp viết code sạch hơn, dễ bảo trì hơn mà còn là một kỹ năng thiết yếu để làm việc hiệu quả với các API, tương tác mạng, và các tác vụ I/O nói chung trong hệ sinh thái JavaScript.</p>
                </div>
            </div>
            <!-- === KẾT THÚC NỘI DUNG THAY THẾ CHO POST 8 === -->
        </div>
    </main>

    <!-- Footer (KHÔNG THAY ĐỔI) -->
    <footer>
        <div class="container">
            <div class="copyright">
                &copy; 2025 IT Journey Blog. Được tạo với ❤️ và nhiều ☕
            </div>
        </div>
    </footer>

    <!-- JavaScript (KHÔNG THAY ĐỔI) -->
    <script>
        // --- HIỆU ỨNG NỀN MẠCH ĐIỆN TỬ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tech-background');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particles = [];
            const particleCount = (canvas.width * canvas.height) / 20000;
            const lineColor = 'rgba(13, 110, 253, 0.5)';
            const particleColor = 'rgba(13, 110, 253, 0.5)';

            function Particle(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                ));
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    p1.x += p1.vx; p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;
                    ctx.beginPath(); ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2); ctx.fillStyle = particleColor; ctx.fill();
                    for (let j = i + 1; j < particles.length; j++) {
                        const p2 = particles[j];
                        const dx = p1.x - p2.x; const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 120) {
                            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = lineColor; ctx.lineWidth = 0.5; ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            
            window.addEventListener('resize', () => {
                 canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                 particles = [];
                 const newParticleCount = (canvas.width * canvas.height) / 20000;
                 for (let i = 0; i < newParticleCount; i++) {
                    particles.push(new Particle(
                        Math.random() * canvas.width, Math.random() * canvas.height,
                        (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                    ));
                }
            });
            draw();
        });
    </script>

    <script src="../cursor-trail.js"></script>
</body>
</html>

