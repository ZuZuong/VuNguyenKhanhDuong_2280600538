<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket Programming 101: Xây dựng Chat Client-Server với Java/Node.js</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Toàn bộ CSS từ post-1.html được sao chép vào đây */
        :root {
            --primary-color: #f8f9fa;
            --secondary-color: #ffffff;
            --accent-color: #0d6efd;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            scroll-behavior: smooth;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        #tech-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header (KHÔNG THAY ĐỔI) */
        header {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 20px 0;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-color);
            text-decoration: none;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }

        nav ul li a {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
            font-weight: 500;
        }

        nav ul li a:hover, nav ul li a.active {
            color: var(--accent-color);
        }
        
        /* CSS cho trang bài viết chi tiết (GIỐNG HỆT POST-1) */
        .post-page-container {
            max-width: 800px; /* Giới hạn chiều rộng nội dung bài viết */
            margin: 0 auto;
            padding: 150px 20px 100px 20px; /* Padding trên cùng để né header */
            background-color: var(--secondary-color);
            min-height: 100vh;
        }
        
        .post-page-title {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        .post-page-content .post-meta {
            display: flex;
            flex-wrap: wrap; /* Thêm cho responsive */
            gap: 10px 20px; /* Thêm gap */
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        
        .post-page-content .post-date,
        .post-page-content .post-author { /* Thêm post-author */
            color: var(--text-secondary);
        }
        
        .post-page-content .post-category {
            background: rgba(13, 110, 253, 0.1);
            color: var(--accent-color);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .post-page-content .post-full-content {
            color: var(--text-color); /* Chữ nội dung rõ hơn */
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .post-page-content .post-full-content h2, 
        .post-page-content .post-full-content h3 {
             color: var(--text-color); 
             margin: 40px 0 15px;
        }

        .post-page-content .post-full-content h2 {
             font-size: 2rem;
             border-bottom: 2px solid var(--border-color);
             padding-bottom: 10px;
        }

         .post-page-content .post-full-content h3 {
             font-size: 1.5rem;
         }
        
        .post-page-content .post-full-content p {
            margin-bottom: 20px;
            color: var(--text-secondary); /* Chỉnh lại màu p */
        }
        
        .post-page-content .post-full-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
            background-color: #eee; /* Nền cho ảnh placeholder */
        }
        
        .post-page-content .post-full-content pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
            margin: 20px 0;
        }
        .post-page-content .post-full-content code {
            font-family: 'Courier New', Courier, monospace;
        }
        .post-page-content .post-full-content blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin: 20px 0;
            font-style: italic;
            color: var(--text-secondary);
        }
        .post-page-content .post-full-content ul, 
        .post-page-content .post-full-content ol { /* Thêm ol */
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        /* Footer */
        footer {
            padding: 50px 0 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--primary-color);
        }

        .copyright {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <canvas id="tech-background"></canvas>
    <header>
        <div class="container">
            <div class="header-content">
                <a href="../index.html" class="logo">My IT Journey Blog</a>
                <nav>
                    <ul>
                        <li><a href="../index.html">Trang Chủ</a></li>
                        <li><a href="../index.html#blog" class="active">Bài Viết</a></li>
                        <li><a href="../about.html">Về Tôi</a></li>
                        <li><a href="../index.html#contact">Liên Hệ</a></li>
                    </ul>
                </nav>
                <div class="mobile-menu">☰</div>
            </div>
        </div>
    </header>

    <main>
         <div class="post-page-container">
            <h1 class="post-page-title">Socket Programming 101: Xây dựng Chat Client-Server với Java/Node.js</h1>
            
            <div class="post-page-content">
                <div class="post-meta">
                    <span class="post-date"><i class="fas fa-calendar-alt"></i> Ngày đăng: 05/11/2025</span>
                    <span class="post-category">Lập trình Mạng</span>
                </div>
                
                <div class="post-full-content">
                    <p>Nếu bạn muốn hiểu cách các ứng dụng thời gian thực như game online, ứng dụng chat, hay streaming hoạt động, bạn phải bắt đầu từ **Socket**. Socket là nền tảng cơ bản của hầu hết mọi giao tiếp mạng. Bài viết này sẽ hướng dẫn các khái niệm cơ bản và cách xây dựng một ứng dụng chat client-server đơn giản.</p>

                    <h2>Socket Là Gì?</h2>
                    <p>Một socket là một **điểm cuối (endpoint)** của một liên kết giao tiếp hai chiều giữa hai chương trình chạy trên mạng. Một socket được ràng buộc (bind) với một số cổng (port) tại một địa chỉ IP cụ thể. Nói một cách đơn giản, nếu địa chỉ IP là tòa nhà của bạn, thì số cổng là số căn hộ của bạn.</p>
                    <p>Chúng ta chủ yếu làm việc với <strong>TCP Sockets</strong>, loại socket sử dụng giao thức TCP (Tầng Vận chuyển) để đảm bảo kết nối tin cậy, có thứ tự và kiểm soát lỗi. Điều này hoàn hảo cho ứng dụng chat, nơi chúng ta không muốn tin nhắn bị mất hoặc đến sai thứ tự.</p>

                    <h2>Kiến Trúc Client-Server</h2>
                    <p>Ứng dụng của chúng ta sẽ có hai phần:</p>
                    <ul>
                        <li><strong>Server (Máy chủ):</strong> Một chương trình chạy liên tục, lắng nghe trên một cổng cụ thể. Nó chấp nhận kết nối từ nhiều client và điều phối tin nhắn giữa họ.</li>
                        <li><strong>Client (Máy khách):</strong> Một chương trình kết nối đến địa chỉ IP và cổng của server. Nó gửi tin nhắn đến server và nhận tin nhắn từ server.</li>
                    </ul>

                    

                    <h2>Ví dụ với Java (java.net)</h2>
                    <p>Java cung cấp các lớp <code>ServerSocket</code> cho máy chủ và <code>Socket</code> cho máy khách.</p>
                    
                    <h3>Code Phía Server (Java - Đơn giản)</h3>
                    <p>Server này chỉ chấp nhận một client và lặp lại tin nhắn của client đó.</p>
                    <pre><code class="language-java">// Server.java
import java.io.*;
import java.net.*;

public class SimpleServer {
    public static void main(String[] args) throws IOException {
        int port = 6789;
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Server đang lắng nghe trên cổng " + port);
            
            // Chờ một client kết nối
            Socket clientSocket = serverSocket.accept(); 
            System.out.println("Client đã kết nối!");

            // Lấy luồng vào/ra
            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

            String inputLine;
            while ((inputLine = in.readLine()) != null) {
                System.out.println("Client nói: " + inputLine);
                out.println("Server nhận được: " + inputLine); // Gửi phản hồi
            }
        }
    }
}</code></pre>

                    <h3>Code Phía Client (Java)</h3>
                    <pre><code class="language-java">// Client.java
import java.io.*;
import java.net.*;

public class SimpleClient {
    public static void main(String[] args) throws IOException {
        String hostName = "127.0.0.1"; // Địa chỉ server (localhost)
        int port = 6789;

        try (
            Socket socket = new Socket(hostName, port);
            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            BufferedReader stdIn = new BufferedReader(new InputStreamReader(System.in))
        ) {
            String userInput;
            System.out.println("Nhập tin nhắn (hoặc 'exit' để thoát):");
            while ((userInput = stdIn.readLine()) != null && !userInput.equals("exit")) {
                out.println(userInput); // Gửi tin nhắn đến server
                System.out.println("Server phản hồi: " + in.readLine()); // Đọc phản hồi
            }
        }
    }
}</code></pre>

                    <h2>Ví dụ với Node.js (Module 'net')</h2>
                    <p>Node.js sử dụng mô hình bất đồng bộ, xử lý nhiều kết nối hiệu quả mà không cần đa luồng (multi-threading) phức tạp.</p>

                    <h3>Code Phía Server (Node.js)</h3>
                    <pre><code class="language-javascript">// server.js
const net = require('net');
const port = 6789;

const server = net.createServer((socket) => {
    console.log('Client đã kết nối!');
    
    // Gửi tin nhắn chào mừng
    socket.write('Chào mừng đến với chat server!\n');

    // Xử lý dữ liệu từ client
    socket.on('data', (data) => {
        console.log(`Client nói: ${data.toString().trim()}`);
        // Phản hồi lại client
        socket.write(`Server nhận được: ${data.toString()}`);
    });

    // Xử lý khi client ngắt kết nối
    socket.on('end', () => {
        console.log('Client đã ngắt kết nối.');
    });

    socket.on('error', (err) => {
        console.error('Lỗi socket:', err.message);
    });
});

server.listen(port, () => {
    console.log(`Server đang lắng nghe trên cổng ${port}`);
});</code></pre>
                    
                    <h3>Code Phía Client (Node.js)</h3>
                    <pre><code class="language-javascript">// client.js
const net = require('net');
const host = '127.0.0.1';
const port = 6789;

const client = net.createConnection({ host, port }, () => {
    console.log('Đã kết nối đến server!');
    console.log('Nhập tin nhắn (hoặc "exit" để thoát):');
});

// Đọc dữ liệu từ server
client.on('data', (data) => {
    console.log(data.toString());
});

// Đọc input từ terminal và gửi đến server
process.stdin.on('data', (input) => {
    const message = input.toString().trim();
    if (message === 'exit') {
        client.end();
        process.exit();
    }
    client.write(message + '\n');
});

client.on('end', () => {
    console.log('Đã ngắt kết nối khỏi server.');
});</code></pre>

                    <h2>Kết Luận</h2>
                    <p>Socket programming là một kỹ năng cơ bản nhưng cực kỳ mạnh mẽ. Từ ví dụ đơn giản này, bạn có thể mở rộng để xử lý nhiều client cùng lúc (bằng cách tạo thread mới cho mỗi client trong Java, hoặc quản lý mảng socket trong Node.js) để xây dựng một phòng chat hoàn chỉnh. Hiểu được cách dữ liệu di chuyển ở tầng này là chìa khóa để làm chủ lập trình mạng.</p>
                </div>
            </div>
            </div>
    </main>

    <footer>
        <div class="container">
            <div class="copyright">
                &copy; 2025 IT Journey Blog. Được tạo với ❤️ và nhiều ☕
            </div>
        </div>
    </footer>

    <script>
        // --- HIỆU ỨNG NỀN MẠCH ĐIỆN TỬ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tech-background');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particles = [];
            const particleCount = (canvas.width * canvas.height) / 20000;
            const lineColor = 'rgba(13, 110, 253, 0.5)';
            const particleColor = 'rgba(13, 110, 253, 0.5)';

            function Particle(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                ));
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    p1.x += p1.vx; p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;
                    ctx.beginPath(); ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2); ctx.fillStyle = particleColor; ctx.fill();
                    for (let j = i + 1; j < particles.length; j++) {
                        const p2 = particles[j];
                        const dx = p1.x - p2.x; const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 120) {
                            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = lineColor; ctx.lineWidth = 0.5; ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            
            window.addEventListener('resize', () => {
                 canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                 particles = [];
                 const newParticleCount = (canvas.width * canvas.height) / 20000;
                 for (let i = 0; i < newParticleCount; i++) {
                    particles.push(new Particle(
                        Math.random() * canvas.width, Math.random() * canvas.height,
                        (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                    ));
                }
            });
            draw();
        });
    </script>

    <script src="../cursor-trail.js"></script>
</body>
</html>