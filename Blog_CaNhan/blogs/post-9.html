<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Đã cập nhật tiêu đề -->
    <title>Phân Tích ReactJS: Tư Duy Component và Cơ Chế Hoạt Động Của Virtual DOM</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Toàn bộ CSS từ post-1.html được sao chép vào đây */
        :root {
            --primary-color: #f8f9fa;
            --secondary-color: #ffffff;
            --accent-color: #0d6efd;
            --text-color: #212529;
            --text-secondary: #6c757d;
            --card-bg: #ffffff;
            --border-color: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            scroll-behavior: smooth;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
            position: relative;
        }

        #tech-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.3;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header (KHÔNG THAY ĐỔI) */
        header {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 20px 0;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            color: var(--accent-color);
            text-decoration: none;
        }

        nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
        }

        nav ul li a {
            color: var(--text-color);
            text-decoration: none;
            transition: color 0.3s;
            font-weight: 500;
        }

        nav ul li a:hover, nav ul li a.active {
            color: var(--accent-color);
        }
        
        /* CSS cho trang bài viết chi tiết (GIỐNG HỆT POST-1) */
        .post-page-container {
            max-width: 800px; /* Giới hạn chiều rộng nội dung bài viết */
            margin: 0 auto;
            padding: 150px 20px 100px 20px; /* Padding trên cùng để né header */
            background-color: var(--secondary-color);
            min-height: 100vh;
        }
        
        .post-page-title {
            font-size: 3rem;
            color: var(--accent-color);
            margin-bottom: 20px;
            line-height: 1.2;
        }
        
        .post-page-content .post-meta {
            display: flex;
            flex-wrap: wrap; /* Thêm cho responsive */
            gap: 10px 20px; /* Thêm gap */
            margin-bottom: 30px;
            font-size: 0.9rem;
        }
        
        .post-page-content .post-date,
        .post-page-content .post-author { /* Thêm post-author */
            color: var(--text-secondary);
        }
        
        .post-page-content .post-category {
            background: rgba(13, 110, 253, 0.1);
            color: var(--accent-color);
            padding: 4px 12px;
            border-radius: 20px;
        }
        
        .post-page-content .post-full-content {
            color: var(--text-color); /* Chữ nội dung rõ hơn */
            line-height: 1.8;
            font-size: 1.1rem;
        }
        
        .post-page-content .post-full-content h2, 
        .post-page-content .post-full-content h3 {
             color: var(--text-color); 
             margin: 40px 0 15px;
        }

        .post-page-content .post-full-content h2 {
             font-size: 2rem;
             border-bottom: 2px solid var(--border-color);
             padding-bottom: 10px;
        }

         .post-page-content .post-full-content h3 {
             font-size: 1.5rem;
         }
        
        .post-page-content .post-full-content p {
            margin-bottom: 20px;
            color: var(--text-secondary); /* Chỉnh lại màu p */
        }
        
        .post-page-content .post-full-content img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            margin: 20px 0;
            background-color: #eee; /* Nền cho ảnh placeholder */
        }
        
        .post-page-content .post-full-content pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.95rem;
            margin: 20px 0;
        }
        .post-page-content .post-full-content code {
            font-family: 'Courier New', Courier, monospace;
        }
        .post-page-content .post-full-content blockquote {
            border-left: 4px solid var(--accent-color);
            padding-left: 15px;
            margin: 20px 0;
            font-style: italic;
            color: var(--text-secondary);
        }
        .post-page-content .post-full-content ul, 
        .post-page-content .post-full-content ol { /* Thêm ol */
            list-style-type: disc;
            margin-left: 20px;
            margin-bottom: 20px;
            color: var(--text-secondary);
        }

        /* Footer */
        footer {
            padding: 50px 0 20px;
            border-top: 1px solid var(--border-color);
            background-color: var(--primary-color);
        }

        .copyright {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <canvas id="tech-background"></canvas>
    <!-- Header (KHÔNG THAY ĐỔI) -->
    <header>
        <div class="container">
            <div class="header-content">
                <a href="../index.html" class="logo">My IT Journey Blog</a>
                <nav>
                    <ul>
                        <li><a href="../index.html">Trang Chủ</a></li>
                        <li><a href="../index.html#blog" class="active">Bài Viết</a></li>
                        <li><a href="../about.html">Về Tôi</a></li>
                        <li><a href="../index.html#contact">Liên Hệ</a></li>
                    </ul>
                </nav>
                <div class="mobile-menu">☰</div>
            </div>
        </div>
    </header>

    <main>
         <!-- Nội dung bài viết chi tiết -->
        <div class="post-page-container">
            <!-- === BẮT ĐẦU NỘI DUNG THAY THẾ CHO POST 9 === -->
            
            <h1 class="post-page-title">Phân Tích ReactJS: Tư Duy Component và Cơ Chế Hoạt Động Của Virtual DOM</h1>
            
            <div class="post-page-content">
                <div class="post-meta">
                    <span class="post-date"><i class="fas fa-calendar-alt"></i> Ngày đăng: 12/11/2025</span>
                    
                    <span class="post-category">Framework</span>
                </div>
                
                <div class="post-full-content">
                    <p>ReactJS, thư viện JavaScript phổ biến bậc nhất để xây dựng giao diện người dùng (UI), đã cách mạng hóa cách chúng ta tiếp cận phát triển frontend. Khác với các framework truyền thống (như Angular đời đầu), React không áp đặt một cấu trúc ứng dụng hoàn chỉnh (unopinionated), mà tập trung vào việc tạo ra các "component" UI linh hoạt, có khả năng tái sử dụng và quản lý trạng thái hiệu quả.</p>

                    <h2>Kiến Trúc Component: Xây Dựng Giao Diện Như Chơi LEGO</h2>
                    <p>Triết lý cốt lõi của React là "component-based architecture". Thay vì thao tác trực tiếp trên một cây DOM lớn, chúng ta chia nhỏ giao diện thành các thành phần độc lập, mỗi thành phần đóng gói HTML (thông qua JSX), CSS (thông qua CSS Modules, Styled Components, hoặc CSS-in-JS), và JavaScript logic của riêng nó.</p>
                    <p>Một ứng dụng React thực chất là một cây các component lồng nhau, nơi dữ liệu chảy từ trên xuống (từ component cha xuống component con) thông qua "props" (properties).</p>
                    <pre><code class="language-jsx">// Cấu trúc cây component (ví dụ)
function App() {
  return (
    &lt;div className="app"&gt;
      &lt;Header user={currentUser} /&gt;
      &lt;main&gt;
        &lt;Sidebar categories={categories} /&gt;
        &lt;PostList posts={posts} /&gt;
      &lt;/main&gt;
      &lt;Footer /&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    <img src="../images/post/unnamed 7.jpg" alt="Sơ đồ cây Component và luồng dữ liệu (props)">
                    
                    <h3>State và Props: Quản Lý Dữ Liệu</h3>
                    <ul>
                        <li><strong>Props (Properties):</strong> Là dữ liệu được truyền từ component cha xuống component con. Props là "read-only" (chỉ đọc) đối với component con.</li>
                        <li><strong>State (Trạng thái):</strong> Là dữ liệu *nội tại* của một component, có thể thay đổi theo thời gian (thường do tương tác người dùng). Khi state thay đổi, React sẽ tự động render lại component đó và các component con của nó. React Hooks (như <code>useState</code>, <code>useEffect</code>) là cách hiện đại để quản lý state và các side effects trong functional components.</li>
                    </ul>

                    <pre><code class="language-jsx">// Ví dụ Functional Component với State và Props
import React, { useState } from 'react';

// Nhận 'initialTitle' qua props
function EditablePostCard({ initialTitle }) { 
    // Quản lý state 'title' nội tại bằng useState
    const [title, setTitle] = useState(initialTitle);
    const [isEditing, setIsEditing] = useState(false);

    const handleEdit = () => setIsEditing(true);
    const handleSave = () => setIsEditing(false); // (Thường sẽ gọi API ở đây)
    const handleChange = (event) => setTitle(event.target.value);

    return (
        &lt;div className="post-card"&gt;
            {isEditing ? (
                &lt;input type="text" value={title} onChange={handleChange} /&gt;
            ) : (
                &lt;h3&gt;{title}&lt;/h3&gt;
            )}
            {isEditing ? (
                &lt;button onClick={handleSave}&gt;Lưu&lt;/button&gt;
            ) : (
                &lt;button onClick={handleEdit}&gt;Sửa&lt;/button&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>

                    <h2>Virtual DOM và Reconciliation: Bí Mật Đằng Sau Hiệu Năng</h2>
                    <p>Thao tác trực tiếp với DOM thật của trình duyệt là một quá trình tốn kém tài nguyên. Mỗi thay đổi nhỏ có thể buộc trình duyệt phải tính toán lại layout và vẽ lại (reflow/repaint) một phần lớn của trang. React giải quyết vấn đề này bằng cách sử dụng "Virtual DOM" (DOM ảo) và một quy trình gọi là "Reconciliation" (Hòa giải).</p>
                    <p>Quy trình diễn ra như sau:</p>
                    <ol>
                        <li><strong>Khi state/props thay đổi:</strong> React tạo ra một cây Virtual DOM mới trong bộ nhớ.</li>
                        <li><strong>Diffing Algorithm:</strong> React so sánh (diff) cây Virtual DOM mới này với cây Virtual DOM trước đó (bản snapshot trước khi thay đổi). Thuật toán diffing của React rất hiệu quả, tập trung vào việc tìm ra tập hợp thay đổi *tối thiểu* cần thiết.</li>
                        <li><strong>Batch Updates:</strong> React nhóm các thay đổi cần thiết lại với nhau.</li>
                        <li><strong>DOM Update:</strong> Cuối cùng, React chỉ thực hiện các thao tác cập nhật tối thiểu đó lên DOM thật của trình duyệt.</li>
                    </ol>
                    <p>Bằng cách giảm thiểu số lượng thao tác trực tiếp lên DOM thật, React đạt được hiệu năng vượt trội, đặc biệt là trong các ứng dụng có giao diện phức tạp và dữ liệu thay đổi thường xuyên.</p>
                    <img src="../images/post/unnamed 9.jpg" alt="Sơ đồ Virtual DOM">

                    <h2>Kết Luận</h2>
                    <p>React không chỉ là một thư viện, nó là một cách tư duy về xây dựng giao diện người dùng. Triết lý component hóa, kết hợp với cơ chế Virtual DOM thông minh, đã làm cho React trở thành một lựa chọn hàng đầu cho việc phát triển các ứng dụng web hiện đại, từ các trang đơn giản đến các hệ thống doanh nghiệp phức tạp. Hiểu rõ hai khái niệm cốt lõi này là nền tảng để làm chủ React.</p>
                </div>
            </div>
            <!-- === KẾT THÚC NỘI DUNG THAY THẾ CHO POST 9 === -->
        </div>
    </main>

    <!-- Footer (KHÔNG THAY ĐỔI) -->
    <footer>
        <div class="container">
            <div class="copyright">
                &copy; 2025 IT Journey Blog. Được tạo với ❤️ và nhiều ☕
            </div>
        </div>
    </footer>

    <!-- JavaScript (KHÔNG THAY ĐỔI) -->
    <script>
        // --- HIỆU ỨNG NỀN MẠCH ĐIỆN TỬ ---
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('tech-background');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let particles = [];
            const particleCount = (canvas.width * canvas.height) / 20000;
            const lineColor = 'rgba(13, 110, 253, 0.5)';
            const particleColor = 'rgba(13, 110, 253, 0.5)';

            function Particle(x, y, vx, vy) { this.x = x; this.y = y; this.vx = vx; this.vy = vy; }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(
                    Math.random() * canvas.width, Math.random() * canvas.height,
                    (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                ));
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let i = 0; i < particles.length; i++) {
                    const p1 = particles[i];
                    p1.x += p1.vx; p1.y += p1.vy;
                    if (p1.x < 0 || p1.x > canvas.width) p1.vx *= -1;
                    if (p1.y < 0 || p1.y > canvas.height) p1.vy *= -1;
                    ctx.beginPath(); ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2); ctx.fillStyle = particleColor; ctx.fill();
                    for (let j = i + 1; j < particles.length; j++) {
                        const p2 = particles[j];
                        const dx = p1.x - p2.x; const dy = p1.y - p2.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 120) {
                            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                            ctx.strokeStyle = lineColor; ctx.lineWidth = 0.5; ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(draw);
            }
            
            window.addEventListener('resize', () => {
                 canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                 particles = [];
                 const newParticleCount = (canvas.width * canvas.height) / 20000;
                 for (let i = 0; i < newParticleCount; i++) {
                    particles.push(new Particle(
                        Math.random() * canvas.width, Math.random() * canvas.height,
                        (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5
                    ));
                }
            });
            draw();
        });
    </script>

    <script src="../cursor-trail.js"></script>
</body>
</html>

